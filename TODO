name app
- save file API
-- tests for API
- SQL API
-- tests for API
add: check enter only one word
set soul into UI
- speak pronunciation
-- download audio
-- play audio
- delete double pronunciations
- change icon for get translation
ref: delete constrain layout
- need norm error message when word not found


fun download(link: String, path: String) {
    URL(link).openStream().use { input ->
        FileOutputStream(File(path)).use { output ->
            input.copyTo(output)
        }
    }
}


getExternalFilesDir
Added in API level 8

public abstract File getExternalFilesDir (String type)

Returns the absolute path to the directory on the primary shared/external
storage device where the application can place persistent files it owns. These
files are internal to the applications, and not typically visible to the user
as media.

This is like getFilesDir() in that these files will be deleted when the
application is uninstalled, however there are some important differences:

    Shared storage may not always be available, since removable media can be
    ejected by the user. Media state can be checked using
    Environment#getExternalStorageState(File).
    There is no security enforced with these files. For example, any
    application holding Manifest.permission.WRITE_EXTERNAL_STORAGE can write
    to these files.

If a shared storage device is emulated (as determined by
Environment#isExternalStorageEmulated(File)), it's contents are backed by a
private user data partition, which means there is little benefit to storing
data here instead of the private directories returned by getFilesDir(), etc.

Starting in Build.VERSION_CODES.KITKAT, no permissions are required to read or
write to the returned path; it's always accessible to the calling app. This
only applies to paths generated for package name of the calling application.
To access paths belonging to other packages,
Manifest.permission.WRITE_EXTERNAL_STORAGE and/or
Manifest.permission.READ_EXTERNAL_STORAGE are required.

On devices with multiple users (as described by UserManager), each user has
their own isolated shared storage. Applications only have access to the shared
storage for the user they're running as.

The returned path may change over time if different shared storage media is
inserted, so only relative paths should be persisted.

Here is an example of typical code to manipulate a file in an application's
shared storage:

void createExternalStoragePrivateFile() {
    // Create a path where we will place our private file on external
    // storage.
    File file = new File(getExternalFilesDir(null), "DemoFile.jpg");

    try {
        // Very simple code to copy a picture from the application's
        // resource into the external file.  Note that this code does
        // no error checking, and assumes the picture is small (does not
        // try to copy it in chunks).  Note that if external storage is
        // not currently mounted this will silently fail.
        InputStream is = getResources().openRawResource(R.drawable.balloons);
        OutputStream os = new FileOutputStream(file);
        byte[] data = new byte[is.available()];
        is.read(data);
        os.write(data);
        is.close();
        os.close();
    } catch (IOException e) {
        // Unable to create file, likely because external storage is
        // not currently mounted.
        Log.w("ExternalStorage", "Error writing " + file, e);
    }
}

void deleteExternalStoragePrivateFile() {
    // Get path for the file on external storage.  If external
    // storage is not currently mounted this will fail.
    File file = new File(getExternalFilesDir(null), "DemoFile.jpg");
    file.delete();
}

boolean hasExternalStoragePrivateFile() {
    // Get path for the file on external storage.  If external
    // storage is not currently mounted this will fail.
    File file = new File(getExternalFilesDir(null), "DemoFile.jpg");
    return file.exists();
}

If you supply a non-null type to this function, the returned file will be
a path to a sub-directory of the given type. Though these files are not
automatically scanned by the media scanner, you can explicitly add them to
the media database with MediaScannerConnection.scanFile. Note that this is not
the same as Environment.getExternalStoragePublicDirectory(), which provides
directories of media shared by all applications. The directories returned here
are owned by the application, and their contents will be removed when the
application is uninstalled. Unlike
Environment.getExternalStoragePublicDirectory(),
the directory returned here will be automatically created for you.

Here is an example of typical code to manipulate a picture in an application's
shared storage and add it to the media database:

void createExternalStoragePrivatePicture() {
    // Create a path where we will place our picture in our own private
    // pictures directory.  Note that we don't really need to place a
    // picture in DIRECTORY_PICTURES, since the media scanner will see
    // all media in these directories; this may be useful with other
    // media types such as DIRECTORY_MUSIC however to help it classify
    // your media for display to the user.
    File path = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File file = new File(path, "DemoPicture.jpg");

    try {
        // Very simple code to copy a picture from the application's
        // resource into the external file.  Note that this code does
        // no error checking, and assumes the picture is small (does not
        // try to copy it in chunks).  Note that if external storage is
        // not currently mounted this will silently fail.
        InputStream is = getResources().openRawResource(R.drawable.balloons);
        OutputStream os = new FileOutputStream(file);
        byte[] data = new byte[is.available()];
        is.read(data);
        os.write(data);
        is.close();
        os.close();

        // Tell the media scanner about the new file so that it is
        // immediately available to the user.
        MediaScannerConnection.scanFile(this,
                new String[] { file.toString() }, null,
                new MediaScannerConnection.OnScanCompletedListener() {
            public void onScanCompleted(String path, Uri uri) {
                Log.i("ExternalStorage", "Scanned " + path + ":");
                Log.i("ExternalStorage", "-> uri=" + uri);
            }
        });
    } catch (IOException e) {
        // Unable to create file, likely because external storage is
        // not currently mounted.
        Log.w("ExternalStorage", "Error writing " + file, e);
    }
}

void deleteExternalStoragePrivatePicture() {
    // Create a path where we will place our picture in the user's
    // public pictures directory and delete the file.  If external
    // storage is not currently mounted this will fail.
    File path = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    if (path != null) {
        File file = new File(path, "DemoPicture.jpg");
        file.delete();
    }
}

boolean hasExternalStoragePrivatePicture() {
    // Create a path where we will place our picture in the user's
    // public pictures directory and check if the file exists.  If
    // external storage is not currently mounted this will think the
    // picture doesn't exist.
    File path = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    if (path != null) {
        File file = new File(path, "DemoPicture.jpg");
        return file.exists();
    }
    return false;
}

Parameters
type 	String: The type of files directory to return. May be null for the root
of the files directory or one of the following constants for a subdirectory:
Environment.DIRECTORY_MUSIC, Environment.DIRECTORY_PODCASTS,
Environment.DIRECTORY_RINGTONES, Environment.DIRECTORY_ALARMS,
Environment.DIRECTORY_NOTIFICATIONS, Environment.DIRECTORY_PICTURES, or
Environment.DIRECTORY_MOVIES. This value may be null.

Returns
File 	the absolute path to application-specific directory. May return null
if shared storage is not currently available.